package wishKnish.knishIO.client

import kotlinx.serialization.*
import kotlinx.serialization.json.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.DisplayName
import wishKnish.knishIO.client.libraries.Shake256
import java.io.File

/**
 * Molecular Hash Cross-Platform Compatibility Test
 * 
 * This test validates that molecular hash inputs generate identical outputs
 * between Noble SHAKE256 (JavaScript) and BouncyCastle SHAKE256 (Kotlin).
 * 
 * CRITICAL SUCCESS CRITERIA:
 * - 100% molecular hash compatibility between platforms
 * - Identical outputs for typical molecular patterns
 * - Validation of fixed SHAKE256 implementation
 * 
 * This test proves that the Noble SHAKE256 bridge solves the root cause
 * of molecular validation failures between Kotlin and JavaScript SDKs.
 */
class MolecularHashCrossCompatibilityTest {
    
    @Serializable
    data class MolecularHashTestVector(
        val name: String,
        val description: String,
        val input: String,
        val inputLength: Int,
        val outputLength: Int,
        val nobleHash: String,
        val library: String,
        val platform: String
    )
    
    @Serializable
    data class MolecularHashTestSuite(
        val timestamp: String,
        val platform: String,
        val hashingLibrary: String,
        val compatibleWith: String,
        val testPurpose: String,
        val description: String,
        val testVectors: List<MolecularHashTestVector>
    )
    
    @Test
    @DisplayName("Validate Noble SHAKE256 molecular hash compatibility with BouncyCastle")
    fun validateNobleBouncyCastleMolecularHashCompatibility() {
        println("\nüî¨ Molecular Hash Cross-Platform Compatibility Test")
        println("Validating Noble SHAKE256 (JavaScript) vs BouncyCastle (Kotlin)")
        println("‚îÅ".repeat(80))
        
        // Load the molecular hash test vectors generated by Noble SHAKE256
        val testSuite = loadMolecularHashTestVectors()
        if (testSuite == null) {
            throw AssertionError("Failed to load molecular hash test vectors. Run JavaScript test first.")
        }
        
        println("üìã Loaded test vectors:")
        println("   Platform: ${testSuite.platform}")
        println("   Library: ${testSuite.hashingLibrary}")
        println("   Compatible With: ${testSuite.compatibleWith}")
        println("   Test Vectors: ${testSuite.testVectors.size}")
        println()
        
        var totalTests = 0
        var passedTests = 0
        var failedTests = 0
        val results = mutableListOf<ValidationResult>()
        
        testSuite.testVectors.forEach { vector ->
            println("üß¨ Testing: ${vector.name}")
            println("   Description: ${vector.description}")
            println("   Input Length: ${vector.inputLength} characters")
            println("   Expected Output Length: ${vector.outputLength} bytes")
            
            try {
                // Generate hash using Kotlin BouncyCastle implementation
                val kotlinHash = Shake256.hash(vector.input, vector.outputLength)
                
                // Compare with Noble SHAKE256 hash
                val isCompatible = kotlinHash.equals(vector.nobleHash, ignoreCase = true)
                
                totalTests++
                if (isCompatible) {
                    passedTests++
                    println("   Result: ‚úÖ PERFECT MATCH")
                    println("   Noble:  ${vector.nobleHash.substring(0, 32)}...")
                    println("   Kotlin: ${kotlinHash.substring(0, 32)}...")
                } else {
                    failedTests++
                    println("   Result: ‚ùå MISMATCH")
                    println("   Noble:  ${vector.nobleHash}")
                    println("   Kotlin: ${kotlinHash}")
                    println("   This indicates a compatibility issue that needs investigation!")
                }
                
                results.add(ValidationResult(
                    name = vector.name,
                    description = vector.description,
                    input = vector.input,
                    inputLength = vector.inputLength,
                    outputLength = vector.outputLength,
                    nobleHash = vector.nobleHash,
                    kotlinHash = kotlinHash,
                    compatible = isCompatible
                ))
                
            } catch (e: Exception) {
                failedTests++
                println("   Result: ‚ùå ERROR - ${e.message}")
                
                results.add(ValidationResult(
                    name = vector.name,
                    description = vector.description,
                    input = vector.input,
                    inputLength = vector.inputLength,
                    outputLength = vector.outputLength,
                    nobleHash = vector.nobleHash,
                    kotlinHash = "ERROR: ${e.message}",
                    compatible = false
                ))
            }
            
            println()
        }
        
        // Generate compatibility report
        generateMolecularHashCompatibilityReport(results, testSuite)
        
        // Export detailed results
        exportMolecularHashValidationResults(results, testSuite)
        
        // Assert perfect compatibility
        val compatibilityRate = (passedTests * 100) / totalTests
        
        println("üìä FINAL MOLECULAR HASH COMPATIBILITY RESULTS:")
        println("   ‚úÖ Passed: $passedTests")
        println("   ‚ùå Failed: $failedTests") 
        println("   üìà Compatibility Rate: $compatibilityRate%")
        
        if (compatibilityRate == 100) {
            println("\nüéØ PERFECT SUCCESS!")
            println("   Noble SHAKE256 provides 100% molecular hash compatibility with BouncyCastle")
            println("   Molecular validation will work perfectly between JavaScript and Kotlin SDKs")
            println("   The SHAKE256 fix has COMPLETELY SOLVED the cross-platform compatibility issue!")
        } else {
            println("\n‚ö†Ô∏è  COMPATIBILITY ISSUES DETECTED!")
            println("   ${failedTests} molecular hash patterns show incompatibility")
            println("   This requires immediate investigation and fixes")
        }
        
        // Assert perfect compatibility for the test
        if (compatibilityRate != 100) {
            throw AssertionError("Molecular hash compatibility is $compatibilityRate%, expected 100%. ${failedTests} tests failed.")
        }
    }
    
    private fun loadMolecularHashTestVectors(): MolecularHashTestSuite? {
        return try {
            val vectorsFile = "molecular-hash-test-vectors-noble.json"
            if (!File(vectorsFile).exists()) {
                println("‚ùå Molecular hash test vectors not found: $vectorsFile")
                println("   Run: node test-bidirectional-molecular-validation.js")
                return null
            }
            
            val jsonContent = File(vectorsFile).readText()
            Json.decodeFromString<MolecularHashTestSuite>(jsonContent)
        } catch (e: Exception) {
            println("‚ùå Failed to load molecular hash test vectors: ${e.message}")
            null
        }
    }
    
    private fun generateMolecularHashCompatibilityReport(
        results: List<ValidationResult>,
        testSuite: MolecularHashTestSuite
    ) {
        println("üìã MOLECULAR HASH COMPATIBILITY ANALYSIS:")
        println("‚îÅ".repeat(50))
        
        // Categorize by molecular pattern type
        val categories = results.groupBy { result ->
            when {
                result.name.contains("simple") -> "Simple Molecules"
                result.name.contains("transfer") -> "Transfer Molecules"
                result.name.contains("continuid") -> "ContinuID Molecules"
                result.name.contains("meta") -> "Meta Molecules"
                result.name.contains("batch") -> "Batch Molecules"
                else -> "Other"
            }
        }
        
        categories.forEach { (category, categoryResults) ->
            val passed = categoryResults.count { it.compatible }
            val total = categoryResults.size
            val rate = (passed * 100) / total
            
            println("${category.padEnd(20)}: ${rate}% ($passed/$total)")
        }
        
        println()
        
        // Critical findings
        val failedResults = results.filter { !it.compatible }
        if (failedResults.isNotEmpty()) {
            println("üö® FAILED MOLECULAR HASH PATTERNS:")
            failedResults.forEach { result ->
                println("   ‚Ä¢ ${result.name}: ${result.description}")
                println("     Input length: ${result.inputLength}, Expected length: ${result.outputLength}")
            }
        }
    }
    
    private fun exportMolecularHashValidationResults(
        results: List<ValidationResult>,
        testSuite: MolecularHashTestSuite
    ) {
        val exportData = MolecularHashValidationReport(
            timestamp = System.currentTimeMillis().toString(),
            testPurpose = "Molecular Hash Cross-Platform Compatibility Validation",
            sourceTestSuite = testSuite,
            kotlinLibrary = "BouncyCastle SHAKEDigest(256)",
            javascriptLibrary = testSuite.hashingLibrary,
            results = results,
            summary = ValidationSummary(
                totalTests = results.size,
                passedTests = results.count { it.compatible },
                failedTests = results.count { !it.compatible },
                compatibilityRate = (results.count { it.compatible } * 100) / results.size
            )
        )
        
        val json = Json { prettyPrint = true }
        val jsonString = json.encodeToString(exportData)
        File("molecular-hash-compatibility-validation-results.json").writeText(jsonString)
        
        println("üìÅ Detailed validation results exported to: molecular-hash-compatibility-validation-results.json")
    }
    
    @Serializable
    data class ValidationResult(
        val name: String,
        val description: String,
        val input: String,
        val inputLength: Int,
        val outputLength: Int,
        val nobleHash: String,
        val kotlinHash: String,
        val compatible: Boolean
    )
    
    @Serializable
    data class ValidationSummary(
        val totalTests: Int,
        val passedTests: Int,
        val failedTests: Int,
        val compatibilityRate: Int
    )
    
    @Serializable
    data class MolecularHashValidationReport(
        val timestamp: String,
        val testPurpose: String,
        val sourceTestSuite: MolecularHashTestSuite,
        val kotlinLibrary: String,
        val javascriptLibrary: String,
        val results: List<ValidationResult>,
        val summary: ValidationSummary
    )
}